## 软件工程复习

[TOC]

选择20分，简答40分，大计算40分

### 概述

* ***软件声明周期包含的时期和阶段，各用来做什么？***
  * 问题定义：通过访问客户调查，简要写出关于系统规模和目的的报告书
  * 可行性研究：系统的高层逻辑模型（数据流图、成本效益分析），写出可行性论证报告
  * 需求分析：系统的逻辑模型（数据流图、数据字典、简要算法描述等），写出规格说明书
  * 概要设计：划分模块及设计模块间关联，生成软件体系结构
  * 详细设计：详细设计每个模块，确定实现模块功能所需的算法和数据结构
  * 编码和单元测试：得到正确的程序模块，写出测试报告
  * 综合测试：测试计划、详细测试方案及实际测试结果报告，实现完整一致的软件配置
  * 软件维护：使系统持久的满足用户的需要

![1530504637409](F:\study\linux和软件工程\软件开发生命周期.png)



* ***各种过程模型的基本思想和使用场景***
  * 瀑布模型
    * 顺序性：前一阶段完成后才能开始后一阶段的工作
    * 依赖性：前一阶段的输出文档是下一阶段的输入文档
    * 缺点：用户只能通过文档了解产品
    * 适用场景：需求明确的，软件实现方法成熟的，项目周期较短
  * 快速原型模型
    * 使用原型（样本）思想获取用户需求，一旦原型完全符合用户需求，开发人员根据其写说明书
    * 适用于：需求不确切
  * 增量模型
    * 把软件产品作为一系列增量构建来设计、编码、集成和测试。完成第一个增量构件后再完成第二个增量构件并与第一个结合，一次类推。`构件：可复用的软件组成成分，可被用来构造其他软件。`
    * 适用场景：需求较为稳定
  * 螺旋模型
    * 增加风险分析过程的瀑布和快速原型混合
    * 适用场景：庞大、复杂并具有高风险的系统，或内部开发的大规模软件项目
  * 喷泉模型
    * 体现软件创建所固有的迭代和无缝隙的特征
    * 适用于面向对象的软件开发

### 可行性和需求分析

#### 数据流图 

![1530515980214](F:\study\linux和软件工程\数据流图基本符号.png)

[安光的作业图书管理系统数据流图、E-R图](https://github.com/Angus-Liu/Notes/blob/master/Notes_Subject/Subject_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BD%9C%E4%B8%9A%EF%BC%9A%E5%9B%BE%E4%B9%A6%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F.md)

#### 数据字典

| 符号 | 说明                             |
| ---- | -------------------------------- |
| =    | 定义为                           |
| +    | 连接                             |
| []   | 从括弧内列出的若干分量中选择一个 |
| {}   | 重复括弧内的分量                 |
| ()   | 圆弧内的分量可有可无             |

比如：购书单=学号+姓名+{书号+数量+单价+总价}+书费合计

年级=[1|2|3|4]、学号=10{数字}10

#### 状态转换图

![1530517758480](F:\study\linux和软件工程\状态图画法.png)

- 初态：同心圆
- 终态：一对同心圆
- 中间态：圆角矩阵
  - 上：状态名称
  - 中：关键变量的名字和值
  - 下：当前状态下需要做的一些事情，不会改变状态
- 状态转换：带箭头的连线

![1530517842623](F:\study\linux和软件工程\电话系统状态转换图.png)

### 设计

#### 结构设计的模块独立化

模块：由边界元素限定的相邻程序元素的序列，有一个总体标识符代替它。

模块化：把程序划分为独立明明且可独立访问的模块。

| 耦合名称                | 描述                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **非直接耦合/完全独立** | 两个模块中的每一个都能独立工作不需要另一个模块的存在         |
| **数据耦合**            | 通过参数交换信息，且交换信息仅仅是数据                       |
| 控制耦合                | 两模块传递信息中含有控制信息                                 |
| 特征耦合                | 把整个数据结构作为参数传递而被调用模块只需要其中一部分数据元素 |
| **公共环境耦合**        | 允许一组模块同时访问同一全局性的数据结构                     |
| 内容耦合                | 一个模块访问另一个模块的内部数据                             |

***内聚***：表示一个模块内各元素彼此结合的紧密程度。

#### 启发式规则

- 改变软件结构提高模块独立性
- 模块规模适中
- 深度、宽度、扇出和扇入都应适当
  - 深度：软件结构中控制的层数
  - 宽度：同一层次上模块总数的最大值
  - 扇入：父模块的个数
  - 扇出：子模块的个数
    - 好的软件结构通常 ***顶层扇出比较高，中层扇出较少，底层扇入到公共的实用模块中去***
- 降低模块接口的复杂程度
- 单入口单出口模块
- 模块功能应该可以预测

#### 数据流图映射到结构图的方法：必考

结构图：方块代表模块，直线代表模块间调用关系，尾部空心圆表示传递 **数据**，实心圆表示传递 **控制信息**

![1530519105106](F:\study\linux和软件工程\系统结构图中模块类型.png)

* 变换流：输入信息经过变换中心加工处理作为另外一种形式离开系统
* 事务流：事务中心T根据输入数据类型在若干个动作序列中选择1个来执行

![1530519386705](F:\study\linux和软件工程\设计过程.png)

####PAD图的画法

![1530519929702](F:\study\linux和软件工程\PAD图的基本符号.png)

![1530520850999](F:\study\linux和软件工程\程序流程图.png)

![1530520878451](F:\study\linux和软件工程\PAD图.png)

### 软件测试

黑盒测试：把程序看做一个黑色子，并不知道里面是啥。用户测试，不了解内部算法实现逻辑的人直接用。

白盒测试：按照程序内部逻辑测试，检测主要执行通路能否按预定要求正确工作。程序员通过调试发现bug。



#### 白盒测试技术

![1530521920897](F:\study\linux和软件工程\测试程序.png)

| 白盒测试技术       | 描述                                                         |                                                              |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 语句覆盖           | 使被测程序中每个语句至少执行一次                             | A=2,B=0,X=4                                                  |
| 分支覆盖(判定覆盖) | 每个判定的每种可能的结果都至少执行1次。                      | `aTbF`:A=3,B=0,X=3<br>`aFbT`:A=2,B=1,X=2                     |
| 条件覆盖           | 判定表达式中每个条件都取到可能的取值                         | 所有条件:<br>`A>1,A<=1`;`B=0,B!=0`;<br>`A=2,A!=2`;`X>1,X<=1` |
| 判定/条件覆盖      | 判定表达式中每个条件取到可能值且每个判定表达式都取到各种结果 |                                                              |
| 条件组合判定       | 使每个判定表达式中条件的各种可能组合出现一次                 | ![1530522663236](F:\study\linux和软件工程\条件组合测试.png)  |

![1530522745626](F:\study\linux和软件工程\各种逻辑覆盖间的关系.png)



- 基本路径测试法

  - 根据程序画出控制流图
  - 计算程序的 **环形复杂度** = 区域数 = `边数-结点数+2` = 判定结点的数目
  - 确定线性独立路径的基本集合，下图中的为`1-11`,`1-2,3-6-7--9-10-1...-11`,`1-2,3-6-8-9-10-1...-11`,`1-2,3-4,5-10-1...-11`
  - 设计可强制执行基本集合中每条路径的测试用例

  ![1530523171273](F:\study\linux和软件工程\基本路径测试法控制流图.png)

#### 黑盒测试技术

* 等价类测试法：在输入数据中选择一些有代表性的数据测试
* 边界值测试法：测试输入等价类和输出等价类边界上的数据
* **渐增式继承测试方法**：把程序分成小段来构造和测试
  * 自顶向下：从主控制模块开始，沿程序的控制层次向下移动。
    * 深度优先
    * 广度优先
  * 自底向上：

#### 软件维护的定义及种类

定义：在软件已经交付使用之后为了改成或满足新的需要而修改软件的过程。

种类：改正性维护、适应性维护、完善性维护、预防性维护

### 面向对象需求分析



![1530524364145](F:\study\linux和软件工程\UML图形分类.png)



[安光的面向对象绘图](https://github.com/Angus-Liu/Notes/blob/master/Notes_Subject/Subject_%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E4%BD%9C%E4%B8%9A%EF%BC%9A%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BB%98%E5%9B%BE.md)