## 处理器管理篇

##### 前趋图：有向无循环图

##### 程序的顺序执行
* 顺序性：每一操作必须在下一个操作开始前结束
* 封闭性：程序运行时独占全机资源
* 可再现性：执行结果不受外界因素影响
![Alt text](./1512017159916.png)

##### 程序的并发执行
并发性：多道程序在同一段时间间隔内同时发生
![Alt text](./1512017167417.png)

* 间断性：执行——暂停——执行
* 室取封闭性：系统资源共享
* 不可再现性：失去封闭性，结果也可以会不相同
### 进程
1. **定义**：进程是进程实体的运行过程，是系统进行*资源分配*的一个*基本单位*。
	* 程序段
	* 数据
	* PCB
2. **特征**
	* *动态性*：由创建而产生，由调度而执行，由撤销而消亡。
	* *并发性*：多个进程实体同存于内存中，且在一段时间内同时运行。程序并不具有。
	* *独立性*：进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。
	* *异步性*：进程按各自独立的、不可预知的速度向前推进。
3. **进程和程序的比较**
	* 程序是有序代码的集合，是一个*静态*的概念。进程是程序的一次执行过程，是一个*动态*概念。
	* 进程是一个状态变化的过程，是*有生命期*的。而程序是*永久*的，可以长久保存。
	* 组成不同。进程由*数据段*、*数据*、*PCB*组成，而程序只是*代码的有序集合*
	* 进程与程序是密切相关的。通过多次执行，**一个程序可对应多个进程**。但进程与它本身所运行的程序只能是一对一的关系。
	* 进程能更真实的描述*并发*，程序不能。
	* *进程可以创建其他进程*，程序不能形成新的程序

#### **进程的三种基本状态及转换**
* 就绪：其他条件满足，仅差CPU
* 执行：获得CPU，执行状态
* 阻塞：由于某事件发生暂时无法执行
 ![Alt text](./1512018336531.png)

* 创建：进程所需的资源(申请PCB、填写控制信息、分配资源等)尚不能得到满足
* 终止：达到自然结束点或出现了无法克服的错误(回收资源、PCB等)
 ![Alt text](./1512018708983.png)
 
* 静止状态：系统不分配CPU
* 引入挂起操作的原因：
	* 终端用户的需求：发现问题希望进程停止以修改
	* 父进程请求
	* 系统负荷的需要		 
 * 操作系统的需要
![Alt text](./1512019403783.png)
挂起原语：**Suspend**，激活原语：**Active**
* 活动就绪(Readya)：未被挂起的就绪态
* 静止就绪(Readys)：将该进程挂起后的状态
* 活动阻塞(Blockeda)：未被挂起的阻塞态
* 静止阻塞(Blockeds)：活动阻塞状态被挂起后的状态
**五个进程状态的转换**
* NULL->创建
* 创建->活动就绪：分配必要资源
* 创建->静止就绪：考虑系统当前资源状况和性能，安置在外存，不参与调度。
* 执行->终止

##### 进程管理中的数据结构
操作系统中的有：内存表、设备表、文件表和进程表(PCB)。
***PCB的作用***
* 作为独立运行基本单位(进程存在于系统中)的*标志*
* 能实现*间断性运行方式*。现场保护与恢复现场。
* 提供进程*管理*所需要的信息。比如文件或程序、I/O设备等
* 提供进程*调度*所需要的信息。比如当前状态、优先级等
* 实现与其他进程的*同步与通信*。比如信号量、通信队列指针等。
**PCB中的信息**
* 进程标识符
	* 外部标识符：方便用户对进程的访问，通常由字母、数字组成。
	* 内部标识符：方便系统对进程的使用，数字。
* CPU上下文：各种寄存器中的内容
* 进程调度信息
	* 进程状态
	* 优先级
	* 调度所需的其他信息
	* 事件(阻塞原因)
* 进程控制信息
	* 程序和数据的地址
	* 进程同步和通信机制
	* 资源清单：一张除CPU以外的进程所需的全部资源和已分配到资源的清单
	* 链接指针

**进程控制块的组织方式**：线性方式、链接方式(具有相同状态进程的PCB链接成一个队列)、索引(根据进程状态不同建立几张索引表)

#### 进程的创建
`一个进程可以创建另一个进程`
1. 申请空白PCB，获得唯一的数字标识符
2. 分配资源，包括各种物理和逻辑资源
3. 初始化PCB：标识信息、处理机状态、控制信息
4. 如果进程就绪队列能够接纳新进程，插入就绪队列
![Alt text](./1512039580446.png)
#### 进程的终止
1. 根据标识符从PCB集合中检索出该进程PCB，读出该进程的状态
2. 若执行态，立即终止该进程的执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度
3. 若有子孙进程，所有子孙进程也终止
4. 被终止进程拥有的所有资源归还父进程或系统
5. 进程(PCB)从队列(链表)中移出

#### 进程的阻塞和唤醒
![Alt text](./1512040054645.png)
### 进程同步：`互斥` `共享`

***临界资源***：仅允许一个进程使用的资源。
**临界区**：每个进程中访问临界资源的那段代码

```cpp
	while(TURE){
		进入区//检查临界资源是否正在被访问
		临界区
		退出区//将临界区正被访问的标志恢复为未被访问标志
		剩余区
	}
```
***同步机制应遵守的规则***
* *空闲让进*：临界资源处于空闲态应允许一个请求进入临界区的进程*立即进入*
* *忙则等待*：临界资源正在被访问时，其他试图进入的必须等待
* *有限等待*：应保证在有限时间内能进入临界区
* *让权等待*：进程不能进入自己的临界区时应立即释放CPU
### 信号量机制
***整型信号量***
>定义一个用于表示资源数目的整型量S，除初始化外仅能通过wait(S)和signal(S)来访问
```
	wait(S){//申请
		while(S<=0);
		S--;
	}
	signal(S){//释放
		S++;
	}
```
`S=0    表示系统中该类临界资源刚好被全部占用，而且没有进程在等待该临界资源。`
`S<0时会不断的测试`
***记录型信号量***：解决让权等待
>除了一个用于表示资源数目的整形变量value外，增加一个进程链表L，用于链接所有等待进程。

```cpp
	typedef struct{
		int value;
		struct process_control_block *list;//阻塞队列
	}semaphore;
	wait(semaphore *S){
		S->value--;
		if(S->value < 0)
			block(S->list);//阻塞原语
	}
	signal(semaphore *S){
		S->value++;
		if(S->value<=0)
			wakeup(S->list);//唤醒原语
	}
```
***AND型信号量***：解决死锁
>将进程在整个运行过程中需要的所有资源，一次性全部地分配给进程，待进程使用完后再一起释放。只要尚有一个资源未能分配给进程，其它所有可能为之分配的资源，也不分配给他。

```cpp
Swait(S1, S2, …, Sn)
    if S1≥1 and … and Sn≥1 then
        for i=1 to n do
        Si=Si-1;
        endfor
    else
     把进程放入第一个阻塞原因的资源等待队列
    endif
Ssignal(S1, S2, …, Sn)
      for i=1 to n do
      Si=Si+1;
      从对应释放资源的等待队列中唤醒一个进程
  endfor; 
```

**信号量集** ???我这里看不太懂
>在AND型信号量的基础上进行扩充，进程对信号量Si的测试值为ti(用于信号量的判断，即Si≥ ti表示资源数量低于ti时不予分配)，占用值为di(用于信号量的增减，即Si= Si-di和Si= Si+di)。

```
	Swait(S1,t1,d1,…,Sn,tn,dn);
	Ssignal(S1,Dn,…,Sn,dn);
```
* `Swait(S, d, d)。 此时在信号量集中只有一个信号量S， 但允许它每次申请d个资源，当现有资源数少于d时，不予分配。`
* `Swait(S, 1, 1)。 此时的信号量集已蜕化为一般的记录型信号量(S＞1时)或互斥信号量(S=1时)。`
* `Swait(S, 1, 0)。这是一种很特殊且很有用的信号量操作。当S≥1时，允许多个进程进入某特定区；当S变为0后，将阻止任何进程进入特定区。换言之，它相当于一个可控开关。 `

##### 利用信号量实现互斥、前趋(前趋图)关系

*互斥信号量*：初始化mutex=1;
|mutex值|意义|
|:----|:--|
|1|临界资源空闲|
|0|有一个进程进入临界区运行|
|-1|有一个已经在运行，有一个还在等|

![前趋图](./1512042565548.png)
```c
p1(){S1;signal(a);signal(b);}
p2(){wait(a);S2;signal(c)；signal(d);}
p3(){wait(b);S3;signal(e);}
p4(){wait(c);S4;signal(f);}
p5(){wait(d);S5;signal(g);}
p6(){wait(e);wait(f);wait(g);S6;}
main(){
	semaphore a,b,c,d,e,f,g;
	a.value=b.value=c.value=d.value=e.value=f.value=g.value=0;
	p1();p2();p3();p4:();p5();p6();
}
```

#### 生产者-消费者问题：满不能生产，空不能消费
[C语言实现源码](https://github.com/Joki-memeda/MyLearning/blob/master/OS/producer-consumer.cpp)
* ```在每个程序中用于实现互斥的wait(mutex)和signal(mutex)必须成对地出现```
* ```每个程序中的多个wait操作顺序不能颠倒。应先执行对资源信号量的wait操作，然后再执行对互斥信号量的wait操作，否则可能引起进程死锁。```

**信号量解决实际问题步骤**
* 信号量的设置
	* `互斥`
	*  `资源`
* 信号量赋初值
	* 互斥=1
	* 资源=0或N
* P、V操作安排的位置
 
#### 进程通信
`作业上有但是我觉得应该不考`
* 共享存储器系统
* 管道通信系统
* 消息传递系统
* 客户机-服务器系统
 
**实现方式**
* 直接消息传递系统
```
send(receiver,message); //发送一个消息给接收进程
receive(sender,message);//接收sender发来的消息
```
* 信箱通信(间接通信方式)
```
	send(mailbox,message);//将一个消息发送到指定邮箱
	receive(mailbox,message);//从指定邮箱中接收一个消息
```
 
### 线程(进程元、轻型进程)
 **线程与进程的比较**
 * *调度的基本单位*。线程时能独立运行的基本单位，切换时仅需保存和设置少量寄存器的内容。
 * *并发性*。更高效地提高系统资源的利用率和吞吐量。
 * *线程并不拥有系统资源*，仅有一点必不可少的、能保证独立运行的资源，比如TCB等
 * 同一进程中的不同线程间的*独立性*比进程间的低的多。
 * 线程的切换*系统开销*比进程的低得多
 * 支持多处理机系统

**线程运行的三个状态**
* 执行：已获得CPU正在运行
* 就绪：具备除CPU外的各种条件
* 阻塞：暂停状态

***TCB***：线程存在的标志

**多线程OS中的进程属性**
* 进程是一个可拥有资源的基本单位
* 多个线程可并发执行
* 进程已不是可执行的实体

##处理机调度
>调度实质是一种资源分配，处理机调度是对处理机资源进行分配。


##### 处理机调度的层次
![CPU调度层次](./1512048568934.png)
* 高级调度(长程调度、**作业**调度)
* 低级调度(短程调度、**进程**调度)
* 中级调度(**内存**调度)：挂起

##### CPU调度算法的目标
1. 资源利用率
 ![CPU的利用率](./1512048647858.png)
2. 公平性：各进程都获得合理的CPU时间，不会发生进程饥饿现象
3. 平衡性：使系统中的各种设备都经常处于忙碌状态
4. 策略强制执行

### 作业(Job)与作业调度
**作业**
不仅包含了通常的*程序和数据*，而且还应配有一份*作业说明书*，系统根据该说明书来对程序的运行进行控制。

**作业步**
每一个加工步骤成为一个作业步。

**作业控制块(JCB)**:作业存在的唯一标志，包含系统对作业管理和调度所需的全部信息

**作业运行的三个阶段和状态**
* 收容状态：输入到外存
* 运行阶段：放回就绪队列，直到运行结束
* 完成阶段：回收资源和JCB，输出结果

**作业调度的主要任务**
>检查系统中的资源能否满足作业对资源的需求，以及按照一定的调度算法，从外存的后备队列中选取某些作业调入内存，并为它们创建进程、分配必要的资源。然后再将新创建的进程排在就绪队列上等待调度。
>* 接纳多少个作业
>* 接纳哪些作业

#### 先来先服务(FCFS)和短作业优先(SJF)
#### 优先级调度算法(PSA)和高响应比优先调度算法(HRRN)
优先级调度算法就是基于作业的紧迫程度由外部赋予优先级，每次从后备队列选择若干个优先级最高的装入内存-。-

高响应比优先算法是结合了FCFS和SJF的算法。优先级相当于响应比RP
![Alt text](./1512049808712.png)
* 作业等待时间相同，服务时间越短，优先级越高，类似SJP算法
* 服务时间相同时，作业的优先权决定于其等待的时间，类似FCFS算法
* 对于长作业的优先级，可以随着等待时间的增加而提高
