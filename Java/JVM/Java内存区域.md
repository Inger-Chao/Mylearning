## 运行时数据区域

Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程的开始和结束而创建和销毁。

![](https://sfault-image.b0.upaiyun.com/147/142/1471427608-558abc24ef69f_articlex)

### Program Counter Register
  Java虚拟机可以支持多条线程同时执行，每一条Java虚拟机线程都有自己的Program Counter Register，它可以看做是当前线程所执行的字节码的行号指示器。
  
  由于Java虚拟机的多线程其实是通过线程轮流切换并分配处理器执行时间来实现的，在任何一个时刻，一个处理器都只会执行一条线程中的指令，每条线程独立，各条线程之间的计数器互不影响，这类内存区域就称为“线程私有”的内存。
  
  如果该线程的当前方法不是Native的，那么计数器的值就保存为JVM正在执行的字节码指令的地址；如果是Native方法，那么计数器的值为空(Undefined)。
  
### Java Virtual Machine Stacks
  
 Java虚拟机栈和计数器一样都是线程私有的，生命周期与线程相同。每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量和一些尚未算好的结果、方法的调用和返回。
 每一个方法从调用到返回的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。
 
 Java 虚拟机规范既允许Java 虚拟机栈被实现成固定大小，也允许根据计算动态来扩展 和收缩。
 
 Java虚拟机栈可能发生两种异常状况：
 
 * StackOverflowError异常：线程请求分配的栈容量超过Java虚拟机栈允许的最大容量
 
 * OutOfMemoryError异常：虚拟机可以动态扩展，扩展时无法申请到足够的内存；在创建新线程时没有足够的内存去创建对应的虚拟机栈
 
### Java Heap
在Java虚拟机中，堆（heap）是可供各个线程共享的运行时内存区域，也是供所有类实例和数组对象分配内存的区域。 

Java堆在虚拟机启动时就被创建，它存储了自动内存管理系统，也就是垃圾收集器(Garbage Collected)所管理的各种对象。

Java堆的容量可以是固定的，也可以随着程序执行的需求动态扩展，并在不需要过多空间时自动收缩。Java堆所使用的内存不需要保证是连续的。
 
 Java堆可能发生的异常状况：
 OutOfMemoryError异常：在堆中没有内存完成实力分配，并且堆也无法再扩展
 
 
 ---------------------------------------------------------------------------------
 参考资料：《Java虚拟机规范(Java SE 8版)》、《深入理解Java虚拟机》
